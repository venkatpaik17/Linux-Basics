Linux console terminal - tty, ctrl+alt+f1/f2/f3/f4/f5/f6/f7, f1/f7/f8 tp reach GUI
to set text size: gsettings set org.gnome.desktop.interface text-scaling-factor 1.1 
/etc/passwd: file contains a list of all the system user accounts, along with basic configuration information about each user
search commands based on keyword: man -k keyword
get info about man page sections: man 1 intro, man 2 intro etc
Filesystem structure and details
Navigation:
	pwd
	cd
	ls
Files:	
	touch
	cp
	mv
	rm
Directories:
	mkdir
	rmdir
	rm
Viewing File contents:
	file
	cat
	more
	less
	head
	tail
	
Sudo:
su - : superuser access 
su - username: switch user
sudo: admin priviliges
sudoers: sudo config file
visudo: editor for sudoers
sudo -k: logout of sudo session
sudo -i: log into root user
whoami: display username of current user
sudo passwd username: change password of the user
sudo passwd -l root: deletes the passwd for root user, basically disables root
sudo adduser name: create a new user account
	whenever a new user is created, sudo is not provided, we need to add that user into sudoers file
	
Users, groups and permissions:	
adduser
sudo useradd -g Group -G groupnames username: create a new user and assign groups (Group is primary group and groupnames are secondary )
groups: lists groups in which current user is present
usermod: to modify attributes/properties of a created user ($ usermod options groups username -> existing user and groups only)
usermod -aG sudo user1: appending user1 to sudo group
sudo cat /etc/group: list of all groups
getent group: same
vipw: used to update /etc/passwd
groupadd: create new groups
vigr: used to update /etc/group
primary group: Login process, files/directories are associated with primary group named after user itself by default. Other groups of which the user is part of are secondary groups
id -gn: to know the primary group (id command: Print user and group information for each specified USER, or for the current user)
sudo usermod -g groupname username: changing user's primary group
userdel username: delete user
groupdel groupname: delete group	
deluser username groupname: remove user from group

chmod: modify permissions
	chmod u,g,o,a -> user group others all
	chmod +,-,= -> operators to add, remove, exact permission
		Ex:chmod u+x,o-r file
		   chmod g=x file
	chmod 700 file -> user has rwx, group and others dont have any, very frequent usage
	r-- is 4, -w- is 2, --x is 1 -> using these we can derive others
	
When you change the permission of directory, the permissions of files/directories inside this directory will be unchanged. To make this happen use -R option

chown: change owner of a file
	chown new_owner filename/directoryname
chgrp: change group of a file
	chgrp new_group filename/directoryname
	For directory, it is not recursive, so to make it happen use -R option
	
Compression and backups:
gzip: gzip filename -> compress
	gzip -d compressed_filename OR gunzip compressed_filename -> decompress
	gzip -c : copy and then compress, preserves original
	
	less file.gz OR zcat file.gz : read the compressed file
	gzip -[1-9] filename: compression quality and time, 1 -> fast but less compressed, 9-> very slow but highly compressed
	
bzip2: similar to gzip, uses bzcat for reading

tar: for archiving multiple files as a single file
	tar pcxzjtvf tar_filename directory -> p preserve permissions, c create, x extract, z gzip compress, t view contents, v verbose, f include file, j bzip2 compress
	

Pipes and Redirection:
stdin 0, stdout 1, stderr 2
echo 'hello' 1> filename OR by default echo 'hello' > filename
cat kslnd 2> error

./demoscript.sh > dsout 2> dserr: stdout goes to dsout and stderr to dserr

./demoscript.sh > combinedouterr 2>&1: both stdout and stderr go to same file combinedouterr

> : stdout overrride the file or create a new file and put it.
>> : stdout append the existing file

Cron jobs:
crontab -l : list cron jobs
crontab -e

***** command : min(0-59), hour(0-23), day of month(1-31), month(1-12), weekday (0-6) sunday-saturday
examples:
	* * * * * command : every minute
	30 2 3 11 * command: 2:30 am on 3rd Nov
	30 10 * * 0 command: 10:30 am every sunday
	0 2 * * * command: 2:00 am every day
	*/5 * * * * command: every 5 minutes
	0 */3 * * * command: every 3 hours
	0 0 1 */3 * command: midnight on 1st every 3 months
	0 0 1 JAN,APR,JUL,OCT command: midnight on 1 st of JAN, APR, JUL, OCT
	5 13 * * 6,0 command: 13:05 pm saturday sunday every week every month
	
Every user has his own crontab file
sudo crontab -e : root crontab file, to be used when commands need root priveleges

Managing Processes:

Process - Parent and child. Process ID - PID, based of which kernel manages process
ctrl+c - SIGINT to the process and stop the process, get out of process
ctrl+z - SIGSTOP to suspend the process, process is still alive but stopped temporarily, gets a JOBID
jobs - get list of jobs
fg jobid - bring back stopped process to foreground using jobid
bg jobid - bring back stopped process to background using jobid, & represents background

command & - creates process in background

Process states -
R – RUNNING/RUNNABLE
S – INTERRRUPTABLE_SLEEP
D – UNINTERRUPTABLE_SLEEP
T – STOPPED
Z – ZOMBIE

ps - list processes, just ps will give processes specific to the user
ps -U username: processes specific to username
ps -aef: e all processes, f full format

top: monitor processes, real time, sorts based on CPU utilization, can sort by any parameter

Signals - using kill command to send signals to processes
kill -l - list of signals

prep processname - to get process id of a process, gives pids of parent processes
pidof processname - to get process id of both parent and child processes
pkill processname - kill a process using processname, if there are multiple processes with same names, then this will kill all of them. Hence it is tricky to use

Process priority-
Niceness - this determines a process's priority, -20 to +19, default niceness is 0, higher niceness means lower execution priority.
High priority is -20, low priority +19
ps -el : to get niceness
nice : execution of a program/process with modified scheduling priority. It launches a process with a user-defined scheduling priority
renice: alters the scheduling priority of one or more running processes



Top-
basic details: time, how long system is up and running, no of users, load average 1min-5min-15min
Tasks: no of tasks, process states of those tasks
%Cpu(s): 
    us: Amount of time the CPU spends executing processes for people in “user space.”
    sy: Amount of time spent running system “kernel space” processes.
    ni: Amount of time spent executing processes with a manually set nice value.
    id: Amount of CPU idle time.
    wa: Amount of time the CPU spends waiting for I/O to complete.
    hi: Amount of time spent servicing hardware interrupts.
    si: Amount of time spent servicing software interrupts.
    st: Amount of time lost due to running virtual machines (“steal time”).
MiB Mem: total amount (in Mebibytes) of physical memory, and how much is free, used, and buffered or cached
MiB swap:total amount (also in Mebibytes) of swap memory, and how much is free, used, and available 

Contents-
    PID: Process ID.
    USER: The owner of the process.
    PR: Process priority.
    NI: The nice value of the process.
    VIRT: Amount of virtual memory used by the process.
    RES: Amount of resident memory used by the process.
    SHR: Amount of shared memory used by the process.
    S: Status of the process. (See the list below for the values this field can take).
    %CPU: The share of CPU time used by the process since the last update.
    %MEM: The share of physical memory used.
    TIME+: Total CPU time used by the task in hundredths of a second.
    COMMAND: The command name or command line (name + options).
    
Customization - u for list user specific process, e for process memory units change, E for dashboard memory unit change, 1 for individual CPU times, t for swaping CPU time displays, m for swapping memory displays, y to highlight running tasks in the process list, x highlights the column used to sort the process list, P for sorting processes based on %CPU column, M for %MEM column, N for PID column, T for TIME+ column, c toggles the COMMAND column between displaying the process name and the full command line, r for renicing a process, W for Save your settings and customizations so they’ll still be in effect when you next start top, F to enter the Fields Management screen.



Package Management:
Package is a group of files which constitute an application. Consists of install scripts, config files, library files and documentation.
Package may have a dependency meaning there are some files/packages which are needed for a package to install and run successfully.
Package manager handles installation and dependencies. 
Repository is a digital library for storing software packages.

dpkg - install, query and remove packages (not the best way to do it)
dpkg -l : list all the installed packages
dpkg -p packagename : details of the specific package
dpkg -s packagename : to check whether that specific package is installed or not, basically gives the status

All ubuntu packages are with .deb extension

dpkg --print-architecture : gives the system architecture
wget link : download files off the internet
dpkg --info packagename.deb : gives information about that package
sudo dpkg -i packagename.deb : install the package
sudo dpkg -r packagename : remove package, keep config files
sudo dpkg -P packagename : remove package and config files, erase all traces

Example for why dpkg isn't good
get the apache deb
sudo dpkg -i apachedeb - errors, dependency problems
dpkg doesn't focus on dependencies, no automatic fix

Built-in package management system apt-get
apt-get will handle package installation, removal and changes along with dependencies on a debian based linux distribution

apt-get uses dpkg under the hood along with other tools
newer versions use only apt (-get is removed)
apt-get update : downloads the list of all packages of all the repos configured in the /etc/apt/sources.list. basically checks for the updates.
apt update --fix-missing 
apt-get upgrade : look at all the local installed packages and fetches the newer versions of the packages if any updates are available. Used to update installed applications. apt update will update the databases and upgrade will get to know about the updates.

-y parameter : yes to avoid prompt

apt-get install <packagename1>... : install packages
sudo apt install -f : Force the package manager to find any missing dependencies or broken packages and install. when dpkg is used for installation
sudo apt install <packagename> --no-upgrade : install package without upgrading
sudo apt install <packagename> --only-upgrade : only upgrade a package but don't want to install it.
sudo apt install <packagename>=<versionnumber> : Install a specific version
apt-cache policy <packagename> :  available versions for specific package
apt --fix-broken install : fix broken installation

sudo apt remove <packagename> : remove installed packages
sudo apt purge <packagename> : another way of removing packages

apt remove just removes the binaries of a package. It leaves residue configuration files.
apt purge removes everything related to a package including the configuration files.

If we use apt remove to remove a software and later install it again, the software will have same config files. But can be overridden during installation.

Purge is useful to completely erase all the traces from the system. Basically useful when configuration is messed up. Also can use oapt purge on already removed packages.

sudo apt autoremove : Removes libs and packages that were installed automatically as dependencies of an installed package, so when package is removed these automatically installed packages which are basically useless remains in the system.

sudo apt --purge autoremove : same as above and also removes configuration files of those dependencies

apt search <searchterm> : finds all packages containing the search term
apt-cache search package : command-line tool used for searching apt packages on a Ubuntu or Debian based systems
apt show <packagename> : Show info about packages, like dependencies, installation, size, sources, desc etc
apt-cache show packagename : detailed info about specific package
apt list --upgradable : Shows all packages that have a newer version ready to be upgraded
apt list --installed : Shows all installed packages on the system
apt list --all-versions : Lists all the packages available for the system

Repositories in ubuntu are divided into main, universe, multiverse, restricted and partner
main - repo enabled by default, consists of FOSS softwares, fully supported by ubuntu developers
universe - FOSS, ubuntu doesn't guarantee security updates, managed by community, vast amount of softwares
multiverse - Not FOSS, licensing, not enabled by default and cannot provide fixes and updates by ubuntu.
restricted - properitary drivers for devices
partners - properitary softwares packaged by ubuntu for patners

Configure a new repo-
cd /etc/apt
vim sources.list

deb repolocation versioncode repotype(s)
ex: deb https:us.archive.ubuntu.com/ bionic main restricted

deb -> binary packages with apt
deb-src ->  source packages for compiling, look at source codes, primary use for developers

OR 
go to sources.list.d
create a file -> filename.list and add your repos
sudo apt update

OR
sudo add-apt-repository 'deb repopath versioncode repotype(s)'
